## 製品コンセプトと必須要件（Novel → Manga Layout）

このWebサービスは、通常のLLMでは扱えない超長文の小説を入力として受け取り、分割・スライド解析を行い、マンガの1エピソード（目安: 30〜50ページ）単位に切り出し、各ページのコマ割り（絵コンテ）を生成する。

重要: 絵の生成はしない。最終的な作画は漫画家が行う。システムは構図・セリフ・位置情報など、レイアウト上の情報を提供する。

### 機能要件

- 長文耐性:
  - 小説全体が数十エピソード、数百ページ規模になっても処理が継続できること
  - 分割（チャンク）とスライド解析により、境界情報の劣化を防ぐこと（重複/オーバーラップを許容）
- エピソード分割:
  - 1エピソード = 約30〜50ページを目安に文字数・シーン密度から自動分割
  - 章・山場・登場人物変化を考慮したナラティブアーク分析
- コマ割り生成:
  - ページ内のコマ数・配置（格子/非格子）・吹き出し位置・セリフ割付の提案
  - 画像を生成せず、構造化出力（JSON/YAML）と必要に応じてプレビュー用描画（線画）に留める
- 再開・リトライ:
  - 途中停止・失敗時に再開可能（idempotent, at-least-once耐性）
  - 進捗（チャンク・エピソード・ページ）の保存と段階的コミット
- 進捗可視化UI:
  - 現在ステップ、件数/割合、残り見積、エラー表示、再開操作
  - 大規模ジョブでもフリーズしないポーリング/イベント更新
- 通知:
  - 完了/停止/失敗時にメール通知（ユーザ設定の通知先に送達）

### 非機能要件

- 耐障害性/再実行性:
  - 各ステップの状態は永続化し、冪等な再実行が可能
  - キュー/ワーカーでバックグラウンド処理、APIリクエスト寿命に依存しない
- スケーラビリティ:
  - ジョブを小さなバッチで進め、R2/KV/DBのI/Oを最適化
  - 大規模入力でもメモリに全読み込みしない
- 監視/運用:
  - ログ、メトリクス、失敗時の原因追跡

### 実装方針（Cursorで守るべき基準）

- チャンク分割とスライド解析:
  - 分析単位はオーバーラップ可能なバッチ。境界またぎの整合性を重視
  - 前回の末尾/次回の先頭を考慮した入力構築（previousEpisodeEndText など）
- バックグラウンド実行:
  - HTTPハンドラで長時間処理を持たない。キュー投入→ワーカーで実行
  - 進捗はDB/KVへ短周期で保存（ポーリングやSSE/WebSocketの負荷を抑制）
- 通知設計:
  - 完了/失敗イベントでメール通知を発火。再通知/集約ポリシーを定義
- 出力契約:
  - エピソード/ページ/コマ/吹き出しを型安全なスキーマで定義し、将来互換を維持
- 表示:
  - プレビュー描画は「線画/枠線/テキスト配置」のみに限定（画像生成は行わない）

### 既存実装との対応（現状）

- 再開API: `src/app/api/jobs/[jobId]/resume/route.ts` はAPI内で処理再開を実行（要改善: 本来はキュー）
- 進捗UI: `src/components/ProcessingProgress.tsx` が `/api/jobs/[jobId]/status` をポーリング
- DBスキーマ: `src/db/schema.ts` にジョブ進捗・履歴の保存フィールドあり
- 分析/分割: `src/utils/episode-utils.ts`, `src/agents/narrative-arc-analyzer.ts` に入力構築とアーク分析

### 改善が必要な点（必須）

- バックグラウンド基盤の導入（Cloudflare Queues/Workflows/Durable Objects）
- 通知サービス（メール）実装とユーザ通知先の保存
- 再開の厳密化（冪等性・重複防止・途中成果の正規化）
- 進捗UIの拡張（ETA、詳細ログ、手動再開/一時停止、失敗時の復旧ガイド）
