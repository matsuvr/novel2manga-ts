# 小説→漫画 処理フロー

このドキュメントは、小説から漫画への変換プロセスの論理フローを概説します。このシステムは、シナリオ定義によって編成されたエージェントのパイプラインを使用して、ジョブキューを介して非同期に小説を処理します。

```mermaid
graph TD
    subgraph ユーザー操作
        A[ユーザー: 小説をアップロード] --> B{APIエンドポイント};
    end

    subgraph オーケストレーション
        B --> C[AnalyzePipelineサービス];
        C --> D{シナリオ: novel-to-manga};
        C --> E[ジョブキュー];
    end

    subgraph 処理パイプライン（非同期ジョブ）
        D -- ステップを定義 --> C;
        C -- 各ステップのジョブを投入 --> E;

        E -- をトリガー --> F[1. NarrativeArcAnalyzer];
        F -- 出力: 物語の構造 --> G[2. PageSplitter];
        G -- 出力: ページ/チャンク (スライディングウィンドウ) --> H[3. ChunkAnalyzer];
        H -- 出力: 分析済みチャンク --> I[4. ChunkBundleAnalyzer];
        I -- 出力: シーン情報 --> J[5. LayoutGenerator];
        J -- 出力: 漫画のパネルレイアウト --> K[最終的な出力];
    end

    %% 注釈
    note for G "小説全体を一定のルールでページ（チャンク）に分割する。
ユーザーが言及した「スライドさせながら」に相当する処理。";
    note for H "各ページ（チャンク）を個別に分析し、登場人物、感情、場所などを抽出する。";
    note for I "分析済みのチャンクを束ねて、より大きな文脈（シーン）を理解・生成する。";
    note for J "シーン情報から、具体的な漫画のコマ割り、カメラアングル、キャラクター配置を決定する。";

```

## 主な特徴

- **シナリオ駆動**: フロー全体が単一のシナリオファイル (`novel-to-manga.ts`) で定義されているため、パイプラインの各ステップが明確で設定可能です。
- **非同期処理**: `AnalyzePipeline`サービスはジョブキューを使用して各エージェントを実行します。これにより、システムをブロックすることなく、長編小説の堅牢なバックグラウンド処理が可能になります。
- **シーケンシャルなデータフロー**: あるエージェントの出力が次のエージェントの入力となり、明確なデータ処理チェーンを形成します。
- **リファクタリングの可能性**: ユーザーは複雑さを懸念しています。これはエージェント間の連携（`input`と`output`の契約）や、特定のエージェントのロジック（例：`ChunkBundleAnalyzer`がチャンクを効果的にグループ化するための複雑なロジック）にある可能性があります。この図は関心事の分離を明確に示しており、どのエージェントがプロセスのどの部分に責任を持つかを特定するのに役立ちます。

### フォーマット方針（重要）

- レイアウトファイル形式は JSON 固定です。
- YAML は廃止済みであり、読み書きのフォールバック実装は存在しません。
- 既存の YAML ファイルが残っている場合は、必要に応じて手動で JSON へ移行してください。
