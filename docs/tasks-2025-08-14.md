# Refactor Tasks — DRY/SOLID/DDD/Microservices Alignment (2025-08-14)

Purpose: execute a structured refactor to enforce repository principles (DRY, SOLID, DDD) and prepare for microservice/serverless execution. These tasks reflect issues identified across API routes, services, and infrastructure boundaries.

## Priority P0 — Critical Architectural Corrections

- [ ] API responsibilities: extract orchestration from route handlers
  - Targets: `src/app/api/analyze/route.ts` (multi-responsibility)
  - Actions: create `JobProgressService` + `EpisodeFlowService` (application services) and move sequence orchestration (validation→storage→job→chunks→progress→analysis kick→episode save) out of the route.
  - Subtasks:
    - [x] Extract layout generation into service (`src/services/application/layout-generation.ts`)
    - [x] Extract rendering into service (`src/services/application/render.ts`)
    - [x] Extract analysis/narrative pipeline into service(s)
    - [x] Extract job details into service (`src/services/application/job-details.ts`) and simplify `/api/job/[id]`
    - [x] Extract export into service; route delegates only (`/api/export` → `OutputService` + `StoragePorts`)
  - Acceptance: route contains IO + delegation only; services unit-tested; behavior unchanged.

- [x] Remove intra-process HTTP self-calls
  - Targets: `src/app/api/analyze/route.ts` `fetch('/api/layout/generate')`, `src/app/api/layout/generate/route.ts` -> `/api/render/batch`
  - Actions: expose a callable use case (e.g., `generateEpisodeLayout(jobId, episodeNumber)` / `renderBatchFromYaml(...)`) and call directly.
  - Acceptance: no internal HTTP between route handlers in same service.

- [ ] Split “God” `DatabaseService` by aggregate
  - Targets: `src/services/database.ts`
  - Actions: carve out aggregate-focused repository/services: `JobProgressService`, `EpisodeWriteService`, `OutputService`; keep `DatabaseService` as infra adapter behind ports.
  - Acceptance: `DatabaseService` becomes thin infra provider (Drizzle adapter), aggregate logic lives in small services.

- [ ] Unify repository DI strategy
  - Targets: usage across routes (factory vs `adaptAll` new Repository)
  - Actions: standardize on request-scoped factory (preferred) or a clear adapter path; avoid mixed construction approaches in the same layer.
  - Acceptance: one DI pattern per route; documented in README/design.

- [ ] Strengthen port contracts (types, steps, progress)
  - Targets: `src/repositories/ports/index.ts`
  - Actions: replace `string` step with typed `JobStep` (template literal unions). Provide types for dynamic steps (e.g., `analyze_chunk_${number}`, `layout_episode_${number}`).
  - Subtasks:
    - [x] Define `JobStep` types and apply to `JobDbPort.updateJobStep`
    - [x] Type `getJobWithProgress` to return `JobProgress | null`
    - [x] Type `updateJobProgress(progress: JobProgress)`
    - [ ] Add lightweight type guards/builders for dynamic steps (helpers)
  - Acceptance: ports compile without loose `string` for steps; tests validate narrowing.

- [ ] Storage boundary abstraction (stop direct StorageFactory usage in app layer)
  - Targets: `/api/analyze`, `/api/export`, `src/services/job-narrative-processor.ts`
  - Actions: define ports: `ChunkStoragePort`, `AnalysisStoragePort`, `LayoutStoragePort`, `RenderStoragePort`, `OutputStoragePort`. Implement adapters using current `StorageFactory`.
  - Subtasks:
    - [x] Define ports and default adapters (`src/infrastructure/storage/ports.ts`)
    - [x] Refactor application services to depend on ports (`layout-generation.ts`, `render.ts`)
    - [ ] Refactor remaining routes/services to ports
      - [x] `/api/analyze` chunk/analysis/novel storage via ports
      - [x] `/api/export` output storage
      - [x] `job-narrative-processor`
  - Acceptance: app/services depend on storage ports only; no direct `StorageFactory` in application layer.

- [ ] Transaction boundaries / Unit-of-Work
  - Targets: chunk writes + job counters, episodes upsert + job totals
  - Actions: introduce Tx port or a scoped Unit-of-Work to ensure atomic updates (where supported by sqlite/Drizzle). Batch operations replace per-item loops where possible.
  - Subtasks:
    - [x] Add `withTransaction` to `DatabaseService`
    - [x] Wrap `createEpisodes` + job totals update in a transaction
    - [x] Add `createChunksBatch` and use it from `/api/analyze` for atomic inserts
    - [ ] Extend repositories to expose transactional boundaries where needed
    - [x] Define Tx ports (`TransactionPort`, `UnitOfWorkPort`) and implement in `DatabaseService` (callback-based Drizzle; begin/commit/rollback no-op)
  - Acceptance: partial failures do not leave inconsistent counters; tests simulate mid-failure.

- [ ] Error/response policy unification
  - Targets: `/api/*` routes using `createErrorResponse` / `handleApiError` / `validationError`
  - Actions: add `ApiResponder` with single policy; route handlers call one entry; Zod/HttpError/infrastructure errors mapped uniformly.
  - Subtasks:
    - [x] Add `src/utils/api-responder.ts` (wraps existing helpers)
    - [x] Refactor routes to import `ApiResponder` (export, render, render/batch)
    - [ ] Apply to remaining routes
      - [x] analyze
      - [x] layout
      - [x] export
      - [x] job status (`/api/jobs/[jobId]/status`)
      - [x] job details (`/api/job/[id]`)
      - [x] analyze chunk (`/api/analyze/chunk`)
  - Acceptance: consistent response envelope across routes; tests verify status codes and schema.

- [ ] Logger abstraction
  - Targets: `console.*` in routes/services (`/api/analyze`, `database.ts`, etc.)
  - Actions: define `LoggerPort` (levels, fields), inject correlation/job/step IDs; adapters for console and platform logs (CF logs).
  - Subtasks:
    - [x] Add `LoggerPort` + `getLogger()` console adapter
    - [x] Use logger in new application services (layout/render)
    - [x] Replace console usage in export/render routes with LoggerPort
    - [ ] Replace in remaining routes/services progressively
      - [x] job status route
      - [x] analyze chunk route
      - [x] export/render routes（前段対応済）
      - [x] job-narrative-processor（全面: LoggerPort DI注入）
  - Acceptance: no stray `console.*` in app/services; logs carry correlation fields.

- [ ] Type strictness clean-up (ban `any`/loose unknown)
  - Targets: lint-reported sites (e.g., `analyze/route.ts` Zod generics, `scene.ts`, `utils/storage.ts`)
  - Actions: replace with generics/brand types; add light wrappers for Zod schemas to avoid `any`.
  - Acceptance: `npm run check` passes without new `any` usage; legacy occurrences reduced where feasible.

## Priority P1 — Processing Model, Orchestration, and Scalability

- [ ] Export as async jobs (PDF/ZIP)
  - Targets: `src/app/api/export/route.ts`
  - Actions: convert to “enqueue and return ticket” API; implement Worker/Queue consumer to generate output and store; status endpoint for completion.
  - Acceptance: API returns immediately with `outputId` ticket; worker produces files; GET returns when ready.

- [ ] Orchestrator/Worker split with queues
  - Targets: `src/services/orchestrator`, `src/services/queue.ts`
  - Actions: turn layout/render/analyze kicks into queued jobs; design idempotency keys; add retry/backoff; pluggable CF Queues adapter.
  - Acceptance: orchestrator sends commands; workers process idempotently; tests for retries and failure paths.

- [ ] Domain service boundaries for narrative processing
  - Targets: `src/services/job-narrative-processor.ts`
  - Actions: inject `JobRepository`, `EpisodeRepository`, storage ports; remove direct infra deps.
  - Acceptance: file depends on ports only; unit tests mock ports.

- [ ] Request-scoped DI; deprecate singleton TTL
  - Targets: `src/repositories/factory.ts`
  - Actions: offer `createRequestContext()` factory; keep legacy singleton behind guard (deprecated). Prefer request context in routes.
  - Acceptance: routes use request-scoped DI; docs updated.

## Priority P2 — Consistency, Performance, Developer Experience

- [ ] ID generation consistency
  - Targets: scattered `randomUUID()`, `makeEpisodeId()` calls
  - Actions: centralize via domain ID factories per aggregate; inject where needed.
  - Acceptance: consistent ID creation strategy; tests prove stable formats.

- [ ] API response envelope uniformity
  - Targets: `/api/analyze`, `/api/export`, others
  - Actions: one success envelope with metadata; align names/fields; deprecate duplicates.
  - Acceptance: contract tests verify schema across endpoints.

- [ ] Parallelism and bulk ops
  - Targets: chunk save loops, output generation
  - Actions: add concurrency with limits; batch writes; guard with Tx/atomic updates.
  - Acceptance: throughput up; no data race; tests validate order and totals.

- [ ] Test coverage and scaffolding
  - Targets: new ports/services
  - Actions: unit tests for services/ports; integration for key flows; minimal E2E to cover critical path.
  - Acceptance: `npm run test:coverage` meaningful; CI green.

## Cross-Cutting Deliverables

- Update design and tasks
  - Files: `.kiro/specs/novel-to-manga-converter/design.md`, `.kiro/specs/novel-to-manga-converter/tasks.md`
  - Keep architecture, contracts, and task status current.

- Lint/format gates
  - Commands: `npm run lint`, `npm run format`, `npm run check`
  - Must pass without new disables; justify any unavoidable exceptions.

## Suggested Execution Order (High-Level)

1. Extract services from `/api/analyze` (P0) and remove internal `fetch` (P0)
   - Status: layout/render extracted; analysis extraction pending.
2. Introduce storage ports and switch app/services to ports (P0)
3. Strengthen port types (`JobStep`/`JobProgress`) (P0)
4. Unify error/response handling; add `LoggerPort` (P0)
5. Add Tx/Unit-of-Work for bulk writes (P0)
6. Convert export to async queue model (P1)
7. Orchestrator/Worker queue split for analyze/layout/render (P1)
8. Request-scoped DI and deprecate singleton TTL (P1)
9. ID factories; response envelope unification; perf (P2)
10. Tests and docs updates throughout (cross-cutting)

---

Notes:

- Cloudflare Workers/Queues/R2 integration must be validated via latest docs (MCP). Include links and constraints in PRs.
- Do not introduce `any`; prefer precise types. Keep ports small and specific (ISP).
